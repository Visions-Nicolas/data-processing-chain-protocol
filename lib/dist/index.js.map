{"version":3,"sources":["../src/index.ts","../src/utils/Logger.ts","../src/types/types.ts","../src/core/Node.ts","../src/agents/Agent.ts","../src/agents/ReportingAgent.ts","../src/agents/MonitoringAgent.ts","../src/core/PipelineProcessor.ts","../src/core/NodeSupervisor.ts","../src/core/NodeSupervisorLogger.ts","../src/extensions/DefaultMonitoringSignalHandler.ts","../src/utils/http.ts","../src/extensions/DefaultReportingCallbacks.ts","../src/extensions/DefaultResolverCallbacks.ts","../src/core/PipelineDataCombiner.ts"],"sourcesContent":["import { NodeSupervisor } from './core/NodeSupervisor';\r\nimport { PipelineProcessor } from './core/PipelineProcessor';\r\n\r\nimport * as MonitoringModule from './extensions/DefaultMonitoringSignalHandler';\r\nimport * as ReportingModule from './extensions/DefaultReportingCallbacks';\r\nimport * as ResolverModule from './extensions/DefaultResolverCallbacks';\r\n\r\nexport { NodeSupervisor };\r\n\r\nexport { PipelineProcessor };\r\n\r\nexport {\r\n  ServiceCallback,\r\n  NodeSignal,\r\n  ChainStatus,\r\n  PipelineData,\r\n  PipelineMeta,\r\n  SupervisorPayload,\r\n  CallbackPayload,\r\n  BrodcastSetupMessage,\r\n  ReportingMessage,\r\n  ChainConfig,\r\n  ChainRelation,\r\n  NodeConfig,\r\n  NodeType,\r\n  ProcessorCallback,\r\n  CombineStrategy,\r\n  CombineFonction,\r\n  SupervisorPayloadSetup,\r\n  SupervisorPayloadCreate,\r\n  SupervisorPayloadDelete,\r\n  SupervisorPayloadPause,\r\n  SupervisorPayloadDelay,\r\n  SupervisorPayloadRun,\r\n  SupervisorPayloadSendData,\r\n  SupervisorPayloadPrepareChain,\r\n  SupervisorPayloadStartChain,\r\n  SupervisorPayloadStartPendingChain,\r\n  SupervisorPayloadDeployChain,\r\n  ChainState,\r\n  DataType,\r\n  ChainType,\r\n  ProcessorPipeline,\r\n  SetupCallback,\r\n  ServiceConfig,\r\n} from './types/types';\r\n\r\nexport { PipelineDataCombiner } from './core/PipelineDataCombiner';\r\n\r\nexport namespace Ext {\r\n  export type BRCPayload = ReportingModule.Ext.BRCPayload;\r\n  export type MCPayload = ReportingModule.Ext.MCPayload;\r\n  export type BSCPayload = ResolverModule.Ext.BSCPayload;\r\n  export type RSCPayload = ResolverModule.Ext.RSCPayload;\r\n  export const Monitoring: typeof MonitoringModule.Ext = MonitoringModule.Ext;\r\n  export const Reporting: typeof ReportingModule.Ext = ReportingModule.Ext;\r\n  export const Resolver: typeof ResolverModule.Ext = ResolverModule.Ext;\r\n}\r\n","import { WriteStream, createWriteStream, mkdirSync } from 'fs';\r\nimport { join } from 'path';\r\nimport { format } from 'util';\r\n\r\n/**\r\n * Represents the log levels for the Logger.\r\n * @typedef {'info' | 'warn' | 'error' | 'header'} LogLevel\r\n */\r\ntype LogLevel = 'info' | 'warn' | 'error' | 'header' | 'debug';\r\n\r\n/**\r\n * Configuration options for the Logger.\r\n * @interface LoggerConfig\r\n * @property {boolean} [preserveLogs] - If true, logs will be preserved and passed to an external callback.\r\n * @property {function(LogLevel, string, string): void} [externalCallback] - A callback function to handle preserved logs.\r\n */\r\ninterface LoggerConfig {\r\n  preserveLogs?: boolean;\r\n  externalCallback?: (\r\n    _level: LogLevel,\r\n    _message: string,\r\n    _timestamp: string,\r\n  ) => void;\r\n}\r\n\r\n// ANSI color codes for console output\r\nconst Colors = {\r\n  reset: '\\x1b[0m',\r\n  info: '\\x1b[32m', // green\r\n  warn: '\\x1b[93m', // yellow\r\n  error: '\\x1b[31m', // red\r\n  header: '\\x1b[36m', // cyan\r\n  debug: '\\x1b[90m', // gray\r\n} as const;\r\n\r\n/**\r\n * Logger class for logging messages to the console and optionally to disk.\r\n */\r\nexport class Logger {\r\n  private static noPrint: boolean = false; // Flag to disable console output\r\n\r\n  private static config: LoggerConfig = {\r\n    preserveLogs: false,\r\n  };\r\n\r\n  /**\r\n   * Configures the logger with the provided options.\r\n   * @param {LoggerConfig} config - The configuration settings for the logger.\r\n   */\r\n  static configure(config: LoggerConfig) {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Formats a log message with a timestamp and color based on the log level.\r\n   * @param {LogLevel} level - The log level for the message.\r\n   * @param {string} message - The message to format.\r\n   * @returns {string} - The formatted log message.\r\n   */\r\n  private static formatMessage(level: LogLevel, message: string): string {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = String(now.getMonth() + 1).padStart(2, '0');\r\n    const day = String(now.getDate()).padStart(2, '0');\r\n    const hours = String(now.getHours()).padStart(2, '0');\r\n    const minutes = String(now.getMinutes()).padStart(2, '0');\r\n    const seconds = String(now.getSeconds()).padStart(2, '0');\r\n    const timestamp = `${year}-${month}-${day}:${hours}.${minutes}.${seconds}`;\r\n    return `${Colors[level]}${timestamp} [${level.toUpperCase()}]: ${message}${Colors.reset}\\n`;\r\n  }\r\n\r\n  /**\r\n   * Logs a message with the specified log level.\r\n   * @param {LogLevel} level - The log level of the message.\r\n   * @param {string} message - The message to log.\r\n   */\r\n  private static log(level: LogLevel, message: string) {\r\n    const timestamp = new Date().toISOString();\r\n    const formattedMessage = this.formatMessage(level, message);\r\n\r\n    if (!this.noPrint) {\r\n      process.stdout.write(formattedMessage);\r\n    }\r\n\r\n    if (this.config.preserveLogs && this.config.externalCallback) {\r\n      this.config.externalCallback(level, message, timestamp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static debug(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('debug', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs an informational message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static info(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('info', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static warn(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('warn', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static error(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('error', msg);\r\n  }\r\n\r\n  /**\r\n   * Logs a header message.\r\n   * @param {string | object} message - The message to log, can be a string or an object.\r\n   */\r\n  static header(message: string | object) {\r\n    const msg = typeof message === 'string' ? message : format(message);\r\n    this.log('header', msg);\r\n  }\r\n}\r\n\r\n// Default log path for disk logging\r\nconst DEFAULT_LOG_PATH = join(process.cwd(), 'logs');\r\nlet logStream: WriteStream;\r\n\r\n/**\r\n * Generates a log file name based on the current timestamp.\r\n * @returns {string} - The generated log file name.\r\n */\r\nconst getLogFileName = () => {\r\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\r\n  return `dpcp-${timestamp}.log`;\r\n};\r\n\r\n/**\r\n * Initializes the disk logger by creating the log directory and file.\r\n * @returns {boolean} - True if the logger was successfully initialized, otherwise false.\r\n */\r\nconst initDiskLogger = () => {\r\n  try {\r\n    mkdirSync(DEFAULT_LOG_PATH, { recursive: true });\r\n    const logFile = join(DEFAULT_LOG_PATH, getLogFileName());\r\n    logStream = createWriteStream(logFile, { flags: 'a' });\r\n    return true;\r\n  } catch (err) {\r\n    process.stderr.write(`Failed to create log directory: ${err}\\n`);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Default callback function for handling logs that should be preserved.\r\n * @param {LogLevel} level - The log level of the message.\r\n * @param {string} message - The message to log.\r\n * @param {string} timestamp - The timestamp of the log message.\r\n */\r\nconst defaultDiskCallback = (\r\n  level: LogLevel,\r\n  message: string,\r\n  timestamp: string,\r\n) => {\r\n  if (!logStream && !initDiskLogger()) {\r\n    return;\r\n  }\r\n  const plainMessage = `${timestamp} [LOGGER][${level.toUpperCase()}]: ${message}\\n`;\r\n  logStream.write(plainMessage);\r\n};\r\n\r\n// Initial configuration of the logger to preserve logs on disk\r\nLogger.configure({\r\n  preserveLogs: true,\r\n  externalCallback: defaultDiskCallback,\r\n});\r\n","/* eslint-disable no-unused-vars */\r\nimport { Logger } from '../utils/Logger';\r\nimport { PipelineProcessor } from '../core/PipelineProcessor';\r\n\r\nexport type ReportingSignalType = 'local-signal' | 'global-signal';\r\nexport type ProcessorPipeline = PipelineProcessor[];\r\nexport type PipelineData = unknown;\r\nexport interface PipelineMeta {\r\n  header?: unknown;\r\n  resolver?: string;\r\n  monitoringHost?: string;\r\n  configuration: unknown;\r\n}\r\nexport interface CallbackPayload {\r\n  chainId?: string;\r\n  targetId: string;\r\n  data: PipelineData;\r\n  meta?: PipelineMeta;\r\n}\r\nexport type ServiceCallback = (payload: CallbackPayload) => void;\r\nexport type SetupCallback = (message: BrodcastSetupMessage) => Promise<void>;\r\nexport type ReportingCallback = (message: ReportingMessage) => Promise<void>;\r\nexport type BroadcastReportingCallback = (\r\n  message: BroadcastReportingMessage,\r\n) => Promise<void>;\r\n\r\nexport namespace DefaultCallback {\r\n  // todo: should be remote_service_callback\r\n  export const SERVICE_CALLBACK: ServiceCallback = (\r\n    payload: CallbackPayload,\r\n  ) => {\r\n    Logger.warn('REMOTE_SERVICE_CALLBACK not set');\r\n  };\r\n  // todo: should be broadcast_setup_callback\r\n  export const SETUP_CALLBACK: SetupCallback = async (\r\n    message: BrodcastSetupMessage,\r\n  ) => {\r\n    Logger.warn('SETUP_CALLBACK not set');\r\n  };\r\n  export const REPORTING_CALLBACK: ReportingCallback = async (\r\n    message: ReportingMessage,\r\n  ) => {\r\n    Logger.warn('REPORTING_CALLBACK not set');\r\n  };\r\n  export const BROADCAST_REPORTING_CALLBACK: ReportingCallback = async (\r\n    message: BroadcastReportingMessage,\r\n  ) => {\r\n    Logger.warn('BROADCAST_REPORTING_CALLBACK not set');\r\n  };\r\n}\r\n\r\nexport type ProcessorCallback = (\r\n  payload: CallbackPayload,\r\n) => Promise<PipelineData>;\r\n\r\nexport namespace NodeType {\r\n  export type Type = 'local' | 'remote';\r\n  export const LOCAL: Type = 'local';\r\n  export const REMOTE: Type = 'remote';\r\n}\r\n\r\nexport namespace DataType {\r\n  export type Type = 'raw' | 'compressed';\r\n  export const RAW: Type = 'raw';\r\n  export const COMPRESSED: Type = 'compressed';\r\n}\r\n\r\nexport namespace CombineStrategy {\r\n  export type Type = 'merge' | 'union' | 'custom';\r\n  export const MERGE: Type = 'merge';\r\n  export const UNION: Type = 'union';\r\n  export const CUSTOM: Type = 'custom';\r\n}\r\n\r\nexport type CombineFonction = (dataSets: PipelineData[]) => unknown[];\r\n\r\nexport interface ChainState {\r\n  completed: string[];\r\n  pending: string[];\r\n  failed: string[];\r\n}\r\n\r\nexport namespace ChainType {\r\n  export type Type = 0b0000010 | 0b00000001;\r\n  export const PERSISTANT: Type = 0b00000010;\r\n  export const DEFAULT: Type = 0b00000001;\r\n}\r\n\r\nexport namespace ChainStatus {\r\n  export type Type =\r\n    | 'node_pending'\r\n    | 'node_in_progress' // running\r\n    | 'node_completed'\r\n    | 'node_failed'\r\n    | 'node_paused'\r\n    | 'node_setup_completed'\r\n    | 'chain_setup_completed'\r\n    | 'child_chain_started'\r\n    | 'child_chain_completed';\r\n  export const NODE_PAUSED: Type = 'node_paused';\r\n  export const NODE_PENDING: Type = 'node_pending';\r\n  export const NODE_IN_PROGRESS: Type = 'node_in_progress';\r\n  export const NODE_COMPLETED: Type = 'node_completed';\r\n  export const NODE_FAILED: Type = 'node_failed';\r\n  export const NODE_SETUP_COMPLETED: Type = 'node_setup_completed';\r\n  export const CHAIN_SETUP_COMPLETED: Type = 'chain_setup_completed';\r\n  export const CHILD_CHAIN_STARTED = 'child_chain_started';\r\n  export const CHILD_CHAIN_COMPLETED = 'child_chain_completed';\r\n}\r\n\r\n// handler signal\r\nexport namespace NodeSignal {\r\n  export type Type =\r\n    | 'node_setup'\r\n    | 'node_create'\r\n    | 'node_delete'\r\n    | 'node_pause'\r\n    | 'node_delay'\r\n    | 'node_run'\r\n    | 'node_send_data'\r\n    | 'chain_prepare'\r\n    | 'chain_start'\r\n    | 'chain_start_pending'\r\n    | 'chain_deploy';\r\n\r\n  export const NODE_SETUP: 'node_setup' = 'node_setup';\r\n  export const NODE_CREATE: 'node_create' = 'node_create';\r\n  export const NODE_DELETE: 'node_delete' = 'node_delete';\r\n  export const NODE_PAUSE: 'node_pause' = 'node_pause';\r\n  export const NODE_DELAY: 'node_delay' = 'node_delay';\r\n  export const NODE_RUN: 'node_run' = 'node_run';\r\n  export const NODE_SEND_DATA: 'node_send_data' = 'node_send_data';\r\n  export const CHAIN_PREPARE: 'chain_prepare' = 'chain_prepare';\r\n  export const CHAIN_START: 'chain_start' = 'chain_start';\r\n  export const CHAIN_START_PENDING: 'chain_start_pending' =\r\n    'chain_start_pending';\r\n  export const CHAIN_DEPLOY: 'chain_deploy' = 'chain_deploy';\r\n}\r\n\r\nexport type SupervisorPayloadSetup = {\r\n  signal: 'node_setup';\r\n  config: NodeConfig;\r\n};\r\n\r\nexport type SupervisorPayloadCreate = {\r\n  signal: 'node_create';\r\n  params: NodeConfig;\r\n};\r\n\r\nexport type SupervisorPayloadDelete = {\r\n  signal: 'node_delete';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadPause = {\r\n  signal: 'node_pause';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadDelay = {\r\n  signal: 'node_delay';\r\n  id: string;\r\n  delay: number;\r\n};\r\n\r\nexport type SupervisorPayloadRun = {\r\n  signal: 'node_run';\r\n  id: string;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayloadSendData = {\r\n  signal: 'node_send_data';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadPrepareChain = {\r\n  signal: 'chain_prepare';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadStartChain = {\r\n  signal: 'chain_start';\r\n  id: string;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayloadStartPendingChain = {\r\n  signal: 'chain_start_pending';\r\n  id: string;\r\n};\r\n\r\nexport type SupervisorPayloadDeployChain = {\r\n  signal: 'chain_deploy';\r\n  config: ChainConfig;\r\n  data: PipelineData;\r\n};\r\n\r\nexport type SupervisorPayload =\r\n  | SupervisorPayloadSetup\r\n  | SupervisorPayloadCreate\r\n  | SupervisorPayloadDelete\r\n  | SupervisorPayloadPause\r\n  | SupervisorPayloadDelay\r\n  | SupervisorPayloadRun\r\n  | SupervisorPayloadSendData\r\n  | SupervisorPayloadPrepareChain\r\n  | SupervisorPayloadStartChain\r\n  | SupervisorPayloadStartPendingChain\r\n  | SupervisorPayloadDeployChain;\r\n\r\nexport interface ServiceConfig {\r\n  targetId: string;\r\n  meta?: PipelineMeta;\r\n}\r\n\r\nexport enum ChildMode {\r\n  NORMAL = 'normal',\r\n  PARALLEL = 'parallel',\r\n}\r\n\r\nexport type NodeConfig = {\r\n  services: (string | ServiceConfig)[];\r\n  chainId: string;\r\n  index?: number; // automatically set\r\n  count?: number; // automatically set\r\n  location?: NodeType.Type;\r\n  nextTargetId?: string;\r\n  nextMeta?: PipelineMeta;\r\n  chainType?: ChainType.Type;\r\n  monitoringHost?: string;\r\n  childMode?: ChildMode;\r\n  chainConfig?: ChainConfig;\r\n};\r\n\r\nexport type ChainConfig = NodeConfig[];\r\nexport interface BrodcastSetupMessage {\r\n  signal: NodeSignal.Type;\r\n  chain: {\r\n    id: string;\r\n    config: ChainConfig;\r\n  };\r\n}\r\n\r\nexport interface ReportingPayload {\r\n  chainId: string;\r\n  nodeId: string;\r\n  index: number;\r\n  count: number;\r\n}\r\n\r\n// todo:\r\nexport interface NotificationStatus {\r\n  status: ChainStatus.Type;\r\n  broadcasted?: boolean;\r\n}\r\n\r\nexport interface ReportingMessage extends ReportingPayload {\r\n  signal: {\r\n    status: ChainStatus.Type;\r\n    broadcasted?: boolean;\r\n  };\r\n}\r\n\r\nexport interface BroadcastReportingMessage extends ReportingPayload {\r\n  signal: {\r\n    status: ChainStatus.Type;\r\n    broadcasted?: boolean;\r\n  };\r\n}\r\n\r\nexport interface ChainRelation {\r\n  rootNodeId?: string;\r\n  dataRef?: PipelineData;\r\n  config: ChainConfig;\r\n}\r\n","import {\r\n  DataType,\r\n  ChainStatus,\r\n  PipelineData,\r\n  ProcessorPipeline,\r\n  NodeType,\r\n  NodeSignal,\r\n  NodeConfig,\r\n  ChainType,\r\n  PipelineMeta,\r\n  ReportingSignalType,\r\n  SupervisorPayloadDeployChain,\r\n  ChildMode,\r\n  NotificationStatus,\r\n} from '../types/types';\r\nimport { setTimeout, setImmediate } from 'timers';\r\nimport { randomUUID } from 'node:crypto';\r\nimport { Logger } from '../utils/Logger';\r\nimport { NodeSupervisor } from './NodeSupervisor';\r\nimport { MonitoringAgent, ReportingAgent } from '../agents/MonitoringAgent';\r\n\r\n/**\r\n * Represents a single executable node within a chain\r\n */\r\nexport class Node {\r\n  private id: string;\r\n  private pipelines: ProcessorPipeline[];\r\n  private dependencies: string[]; // Todo\r\n  private status: ChainStatus.Type;\r\n  private error?: Error;\r\n  private delay: number;\r\n  private progress: number;\r\n  private dataType: DataType.Type;\r\n  private executionQueue: Promise<void>;\r\n  private output: PipelineData[];\r\n  private nextNodeInfo: {\r\n    id: string;\r\n    type: NodeType.Type;\r\n    meta?: PipelineMeta;\r\n  } | null;\r\n  private config: NodeConfig | null;\r\n  private reporting: ReportingAgent | null = null;\r\n\r\n  /**\r\n   * Creates a new Node instance\r\n   * @param {string[]} dependencies - Array of node dependency IDs\r\n   */\r\n  constructor(dependencies: string[] = []) {\r\n    this.id = randomUUID();\r\n    this.output = [];\r\n    this.pipelines = [];\r\n    this.dependencies = dependencies;\r\n    this.status = ChainStatus.NODE_PENDING;\r\n    this.delay = 0;\r\n    this.progress = 0;\r\n    this.dataType = DataType.RAW;\r\n    this.executionQueue = Promise.resolve();\r\n    this.nextNodeInfo = null;\r\n    this.config = null;\r\n  }\r\n\r\n  /**\r\n   * Updates the execution progress based on pipeline count\r\n   * @private\r\n   */\r\n  private updateProgress(): void {\r\n    this.progress += 1 / this.pipelines.length;\r\n  }\r\n\r\n  /**\r\n   * Configures the node and sets up monitoring if index is provided\r\n   * @param {NodeConfig} config - Configuration containing services, chainId, index and other options\r\n   */\r\n  setConfig(config: NodeConfig): void {\r\n    const { chainId, index, count } = config;\r\n    if (index !== undefined && count !== undefined) {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      this.reporting = monitoring.genReportingAgent({\r\n        chainId,\r\n        nodeId: this.id,\r\n        index,\r\n        count,\r\n      });\r\n    } else {\r\n      Logger.warn('Node index is not defined, configuration failed');\r\n    }\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Gets the node's current execution queue promise\r\n   * @returns {Promise<void>} Current execution queue\r\n   */\r\n  getExecutionQueue(): Promise<void> {\r\n    return this.executionQueue;\r\n  }\r\n\r\n  /**\r\n   * Gets the node's configuration\r\n   * @returns {NodeConfig | null} Node configuration if set\r\n   */\r\n  getConfig(): NodeConfig | null {\r\n    return this.config;\r\n  }\r\n\r\n  /**\r\n   * Gets the node's unique identifier\r\n   * @returns {string} UUID of the node\r\n   */\r\n  getId(): string {\r\n    return this.id;\r\n  }\r\n\r\n  /**\r\n   * Adds a processor pipeline to the node\r\n   * @param {ProcessorPipeline} pipeline - Array of PipelineProcessor instances\r\n   */\r\n  addPipeline(pipeline: ProcessorPipeline): void {\r\n    this.pipelines.push(pipeline);\r\n  }\r\n\r\n  /**\r\n   * Digest the data through successive processing stages\r\n   * @param {ProcessorPipeline} pipeline - Array of processors to execute\r\n   * @param {PipelineData} data - Data to process\r\n   * @returns {Promise<PipelineData>} Processed data\r\n   * @private\r\n   */\r\n  private async processPipeline(\r\n    pipeline: ProcessorPipeline,\r\n    data: PipelineData,\r\n  ): Promise<PipelineData> {\r\n    let result = data;\r\n    for (const processor of pipeline) {\r\n      result = await processor.digest(result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private *getPipelineGenerator(\r\n    pipelines: ProcessorPipeline[],\r\n    count: number,\r\n  ): Generator<ProcessorPipeline[], void, unknown> {\r\n    for (let i = 0; i < pipelines.length; i += count) {\r\n      yield pipelines.slice(i, i + count);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notifies about node status changes through the reporting agent\r\n   * @param {ChainStatus.Type} notify - Node status to report\r\n   */\r\n  notify(\r\n    status: ChainStatus.Type | NotificationStatus,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    try {\r\n      if (this.reporting !== null) {\r\n        if (typeof status === 'object' && 'status' in status) {\r\n          this.reporting.notify(status, type);\r\n        } else {\r\n          this.reporting.notify({ status }, type);\r\n        }\r\n      } else {\r\n        throw new Error('Reporter not set');\r\n      }\r\n    } catch (error) {\r\n      Logger.error((error as Error).message);\r\n    }\r\n  }\r\n\r\n  private async processChildChain(data: PipelineData): Promise<void> {\r\n    if (this.config?.chainConfig) {\r\n      const supervisor = NodeSupervisor.retrieveService();\r\n      const chainId = await supervisor.handleRequest({\r\n        signal: NodeSignal.CHAIN_DEPLOY,\r\n        config: this.config.chainConfig,\r\n        data,\r\n      } as SupervisorPayloadDeployChain);\r\n      if (!chainId) {\r\n        throw new Error('Failed to deploy chain: no chainId returned');\r\n      }\r\n      if (this.config.childMode === ChildMode.PARALLEL) {\r\n        this.notify(ChainStatus.CHILD_CHAIN_STARTED, 'global-signal');\r\n        supervisor\r\n          .startChain(chainId, data)\r\n          .then(() =>\r\n            this.notify(ChainStatus.CHILD_CHAIN_COMPLETED, 'global-signal'),\r\n          )\r\n          .catch((error) => {\r\n            Logger.error(`Failed to start parallel child chain: ${error}`);\r\n          });\r\n      } else {\r\n        await supervisor.startChain(chainId, data);\r\n        this.notify(ChainStatus.CHILD_CHAIN_COMPLETED, 'global-signal');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes node processing on input data\r\n   * @param {PipelineData} data - Data to process\r\n   * @returns {Promise<void>}\r\n   */\r\n  async execute(data: PipelineData): Promise<void> {\r\n    this.executionQueue = this.executionQueue.then(async () => {\r\n      try {\r\n        this.updateStatus(ChainStatus.NODE_IN_PROGRESS);\r\n        // todo: monitor this step\r\n        if (this.delay > 0) {\r\n          await this.sleep(this.delay);\r\n        }\r\n\r\n        const generator = this.getPipelineGenerator(this.pipelines, 3);\r\n\r\n        for (const pipelineBatch of generator) {\r\n          await new Promise<void>((resolve, reject) => {\r\n            setImmediate(async () => {\r\n              try {\r\n                const batchPromises = pipelineBatch.map((pipeline) =>\r\n                  this.processPipeline(pipeline, data).then(\r\n                    (pipelineData: PipelineData) => {\r\n                      this.output.push(pipelineData);\r\n                      this.updateProgress();\r\n                      // todo: monitor this step\r\n                    },\r\n                  ),\r\n                );\r\n                await Promise.all(batchPromises);\r\n                resolve();\r\n              } catch (error) {\r\n                reject(error);\r\n              }\r\n            });\r\n          });\r\n        }\r\n\r\n        this.updateStatus(ChainStatus.NODE_COMPLETED);\r\n        if (this.config?.chainConfig) {\r\n          await this.processChildChain(data);\r\n        }\r\n      } catch (error) {\r\n        this.updateStatus(ChainStatus.NODE_FAILED, error as Error);\r\n        Logger.error(`Node ${this.id} execution failed: ${error}`);\r\n      }\r\n    });\r\n\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n    await supervisor.handleRequest({\r\n      signal: NodeSignal.NODE_SEND_DATA,\r\n      id: this.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sends processed data to the next node after execution completion\r\n   * @returns {Promise<void>}\r\n   */\r\n  async sendData(): Promise<void> {\r\n    // make sure the queue has finished\r\n    await this.executionQueue;\r\n    Logger.info(`Sending data from node ${this.id}.`);\r\n    await Node.terminate(this.id, this.output);\r\n  }\r\n\r\n  /**\r\n   * Terminates node execution and handles final data\r\n   * @param {string} nodeId - Node identifier\r\n   * @param {PipelineData[]} pipelineData - Array of processed data\r\n   * @private\r\n   * @static\r\n   */\r\n  private static async terminate(nodeId: string, pipelineData: PipelineData[]) {\r\n    // todo: format data\r\n    const data = pipelineData[0]; // tmp\r\n    await Node.moveToNextNode(nodeId, data);\r\n  }\r\n\r\n  // todo: should not be static\r\n  /**\r\n   * Routes data to next node based on NodeType (LOCAL/REMOTE)\r\n   * @param {string} nodeId - Current node identifier\r\n   * @param {PipelineData} pipelineData - Data to pass forward\r\n   * @private\r\n   * @static\r\n   */\r\n  private static async moveToNextNode(\r\n    nodeId: string,\r\n    pipelineData: PipelineData,\r\n  ) {\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n    const nodes = supervisor.getNodes();\r\n    const currentNode = nodes.get(nodeId);\r\n    if (!currentNode) {\r\n      Logger.warn(`Node ${nodeId} not found for moving to next node.`);\r\n      return;\r\n    }\r\n    const nextNodeInfo = currentNode.getNextNodeInfo();\r\n    if (nextNodeInfo) {\r\n      if (nextNodeInfo.type === NodeType.LOCAL) {\r\n        await supervisor.handleRequest({\r\n          signal: NodeSignal.NODE_RUN,\r\n          id: nextNodeInfo.id,\r\n          data: pipelineData,\r\n        });\r\n      } else if (nextNodeInfo.type === NodeType.REMOTE) {\r\n        supervisor.remoteServiceCallback({\r\n          // targetId and meta are related to the next remote target service uid\r\n          chainId: currentNode.getConfig()?.chainId,\r\n          targetId: nextNodeInfo.id,\r\n          data: pipelineData,\r\n          meta: nextNodeInfo.meta,\r\n        });\r\n      }\r\n    } else {\r\n      Logger.info(`End of pipeline reached by node ${nodeId}.`);\r\n      // currentNode.reporting.notify();\r\n    }\r\n    const isPersistant =\r\n      (currentNode.config?.chainType ?? 0) & ChainType.PERSISTANT;\r\n    if (!isPersistant) {\r\n      await supervisor.handleRequest({\r\n        id: nodeId,\r\n        signal: NodeSignal.NODE_DELETE,\r\n      });\r\n    } else {\r\n      Logger.warn(`Node ${nodeId} kept for future calls.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets execution progress value\r\n   * @returns {number} Progress between 0 and 1\r\n   */\r\n  getProgress(): number {\r\n    return this.progress;\r\n  }\r\n\r\n  /**\r\n   * Checks if node dependencies are satisfied\r\n   * @param {Set<string>} executedNodes - Set of completed node IDs\r\n   * @returns {boolean} Whether node can execute\r\n   */\r\n  canExecute(executedNodes: Set<string>): boolean {\r\n    return this.dependencies.every((dep) => executedNodes.has(dep));\r\n  }\r\n\r\n  /**\r\n   * Sets execution delay in milliseconds\r\n   * @param {number} delay - Delay amount\r\n   */\r\n  setDelay(delay: number): void {\r\n    this.delay = delay;\r\n  }\r\n\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Gets current data type (RAW/COMPRESSED)\r\n   * @returns {DataType.Type} Current data type\r\n   */\r\n  getDataType(): DataType.Type {\r\n    return this.dataType;\r\n  }\r\n\r\n  /**\r\n   * Gets current node status\r\n   * @returns {ChainStatus.Type} Current chain status\r\n   */\r\n  getStatus(): ChainStatus.Type {\r\n    return this.status;\r\n  }\r\n\r\n  /**\r\n   * Gets node dependency IDs\r\n   * @returns {string[]} Array of dependency node IDs\r\n   */\r\n  getDependencies(): string[] {\r\n    return this.dependencies;\r\n  }\r\n\r\n  /**\r\n   * Updates node status and handles error reporting\r\n   * @param {ChainStatus.Type} status - New status to set\r\n   * @param {Error} [error] - Optional error if status is NODE_FAILED\r\n   */\r\n  updateStatus(status: ChainStatus.Type, error?: Error): void {\r\n    this.status = status;\r\n    if (status === ChainStatus.NODE_FAILED) {\r\n      this.error = error;\r\n    }\r\n    if (this.reporting) {\r\n      this.reporting.notify({ status });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets last error if node failed\r\n   * @returns {Error|undefined} Error object if failed\r\n   */\r\n  getError(): Error | undefined {\r\n    return this.error;\r\n  }\r\n\r\n  /**\r\n   * Gets all processor pipelines\r\n   * @returns {ProcessorPipeline[]} Array of processor pipelines\r\n   */\r\n  getProcessors(): ProcessorPipeline[] {\r\n    return this.pipelines;\r\n  }\r\n\r\n  /**\r\n   * Sets next node routing information\r\n   * @param {string} id - Next node ID\r\n   * @param {NodeType.Type} type - Next node type (LOCAL/REMOTE)\r\n   * @param {PipelineMeta} [meta] - Optional pipeline metadata for next node\r\n   */\r\n  setNextNodeInfo(id: string, type: NodeType.Type, meta?: PipelineMeta): void {\r\n    this.nextNodeInfo = { id, type, meta };\r\n  }\r\n\r\n  /**\r\n   * Gets next node routing information\r\n   * @returns {{ id: string, type: NodeType.Type, meta?: PipelineMeta } | null} Next node info or null\r\n   */\r\n  getNextNodeInfo(): {\r\n    id: string;\r\n    type: NodeType.Type;\r\n    meta?: PipelineMeta;\r\n  } | null {\r\n    return this.nextNodeInfo;\r\n  }\r\n}\r\n","import EventEmitter from 'node:events';\r\nimport { randomUUID } from 'node:crypto';\r\n\r\n/**\r\n * Abstract base Agent class that extends EventEmitter\r\n * @abstract\r\n */\r\nexport abstract class Agent extends EventEmitter {\r\n  protected uid: string;\r\n\r\n  /**\r\n   * Creates a new Agent instance with a unique identifier\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.uid = randomUUID();\r\n  }\r\n}\r\n","import { Logger } from '../utils/Logger';\r\nimport { Agent } from './Agent';\r\nimport {\r\n  ChainStatus,\r\n  NotificationStatus,\r\n  ReportingSignalType,\r\n} from '../types/types';\r\n\r\n/**\r\n * Abstract base class for a node monitoring and status reporting agent\r\n * @abstract\r\n */\r\nexport abstract class ReportingAgentBase extends Agent {\r\n  private static authorizedAgent: Agent | null = null;\r\n  private status: ChainStatus.Type[] = [];\r\n\r\n  /**\r\n   * Creates a new ReportingAgentBase instance\r\n   * @throws {Error} Throws an error if the agent instantiating this instance is not authorized.\r\n   */\r\n  constructor() {\r\n    super();\r\n    if (!(ReportingAgentBase.authorizedAgent instanceof Agent)) {\r\n      throw new Error(\r\n        'Node Reporter needs to be instantiated by an authorized Agent',\r\n      );\r\n    }\r\n    ReportingAgentBase.authorizedAgent = null;\r\n  }\r\n\r\n  /**\r\n   * Authorizes an agent to create ReportingAgent instances\r\n   * @param {Agent} agent - The agent to authorize\r\n   */\r\n  static authorize(agent: Agent): void {\r\n    ReportingAgentBase.authorizedAgent = agent;\r\n  }\r\n\r\n  /**\r\n   * Notifies about a new chain status\r\n   * @param {ChainStatus.Type} status - The status to notify\r\n   * @param {ReportingSignalType} type - The type of signal ('local-signal' by default)\r\n   */\r\n  notify(\r\n    notificationStatus: NotificationStatus,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    const { status } = notificationStatus;\r\n    Logger.info(`Status ${status} from ${this.uid}`);\r\n    this.status.push(status);\r\n    this.emit(type, notificationStatus);\r\n  }\r\n\r\n  /**\r\n   * Gets all recorded signals/statuses\r\n   * @returns {ChainStatus.Type[]} Array of recorded chain statuses\r\n   */\r\n  getSignals(): ChainStatus.Type[] {\r\n    return this.status;\r\n  }\r\n}\r\n","import {\r\n  DefaultCallback,\r\n  NodeSignal,\r\n  ReportingCallback,\r\n  ReportingMessage,\r\n  ReportingPayload,\r\n} from '../types/types';\r\nimport { Logger } from '../utils/Logger';\r\nimport { Agent } from './Agent';\r\nimport { ReportingAgentBase } from './ReportingAgent';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\n/**\r\n * Class for a node monitoring and status reporting agent\r\n */\r\nexport class ReportingAgent extends ReportingAgentBase {\r\n  /**\r\n   * Creates a new ReportingAgent instance\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {string} nodeId - The node identifier\r\n   */\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    readonly chainId: string,\r\n    // eslint-disable-next-line no-unused-vars\r\n    readonly nodeId: string,\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport interface MonitoringChainStatus {\r\n  [key: string]: {\r\n    [key: string]: boolean;\r\n  };\r\n}\r\nexport interface WorkflowNode {\r\n  status?: MonitoringChainStatus;\r\n  setupCount?: number;\r\n}\r\n\r\nexport interface Workflow {\r\n  [key: string]: WorkflowNode;\r\n}\r\n\r\n/**\r\n * Responsible for managing all reporting agents and the monitoring of nodes within a processing chain\r\n */\r\nexport class MonitoringAgent extends Agent {\r\n  private static instance: MonitoringAgent;\r\n  private reportingCallback: ReportingCallback;\r\n  private broadcastReportingCallback: ReportingCallback;\r\n  private remoteMonitoringHost: Map<string, string>;\r\n  private workflow: Workflow;\r\n\r\n  private chainHierarchy: Map<\r\n    string,\r\n    {\r\n      parentId?: string;\r\n      children: string[];\r\n      completedChildren: Set<string>;\r\n    }\r\n  > = new Map();\r\n\r\n  /**\r\n   * Creates a new MonitoringAgent instance\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.workflow = {};\r\n    this.remoteMonitoringHost = new Map();\r\n    this.reportingCallback = DefaultCallback.REPORTING_CALLBACK;\r\n    this.broadcastReportingCallback =\r\n      DefaultCallback.BROADCAST_REPORTING_CALLBACK;\r\n  }\r\n\r\n  getWorkflow(): Workflow {\r\n    return this.workflow;\r\n  }\r\n  /**\r\n   * Retrieves or creates a MonitoringAgent instance (Singleton pattern)\r\n   * @param {boolean} refresh - Whether to force create a new instance\r\n   * @returns {MonitoringAgent} The MonitoringAgent instance\r\n   */\r\n  static retrieveService(refresh: boolean = false): MonitoringAgent {\r\n    if (!MonitoringAgent.instance || refresh) {\r\n      const instance = new MonitoringAgent();\r\n      MonitoringAgent.instance = instance;\r\n    }\r\n    return MonitoringAgent.instance;\r\n  }\r\n\r\n  /**\r\n   * Sets the reporting callback function\r\n   * @param {ReportingCallback} reportingCallback - The callback function to handle reports\r\n   */\r\n  setReportingCallback(reportingCallback: ReportingCallback): void {\r\n    this.reportingCallback = reportingCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast reporting callback function\r\n   * @param {ReportingCallback} broadcastReportingCallback - The callback function to handle broadcast reports\r\n   */\r\n  setBroadcastReportingCallback(\r\n    broadcastReportingCallback: ReportingCallback,\r\n  ): void {\r\n    this.broadcastReportingCallback = broadcastReportingCallback;\r\n  }\r\n\r\n  /**\r\n   * Gets the remote monitoring host for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {string|undefined} The remote monitoring host address if exists\r\n   */\r\n  getRemoteMonitoringHost(chainId: string): string | undefined {\r\n    return this.remoteMonitoringHost.get(chainId);\r\n  }\r\n\r\n  /**\r\n   * Sets the remote monitoring host for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {string} remoteMonitoringHost - The remote monitoring host address\r\n   */\r\n  setRemoteMonitoringHost(chainId: string, remoteMonitoringHost: string): void {\r\n    this.remoteMonitoringHost.set(chainId, remoteMonitoringHost);\r\n  }\r\n\r\n  /**\r\n   * Generates a new ReportingAgent instance\r\n   * @param {ReportingPayload} payload - The reporting payload containing chainId, nodeId and index\r\n   * @returns {ReportingAgent} A new ReportingAgent instance\r\n   */\r\n  genReportingAgent(payload: ReportingPayload): ReportingAgent {\r\n    const { chainId, nodeId, index } = payload;\r\n    ReportingAgent.authorize(this);\r\n    const reporting = new ReportingAgent(chainId, nodeId);\r\n    // Handle global-signal\r\n    // This is the main process for redirecting signals and communicating with the\r\n    // entire context. It is called after any global notification\r\n    // todo: add type for signals\r\n    reporting.on('global-signal', async (signal) => {\r\n      Logger.info(`Receive global-signal: ${signal} for node ${nodeId}`);\r\n      const message: ReportingMessage = { ...payload, signal };\r\n      if (index > 0) {\r\n        // Report message to distant monitoring host\r\n        signal.broadcasted = true;\r\n        void this.broadcastReportingCallback(message);\r\n      } else {\r\n        // Report message to monitoring\r\n        await this.reportingCallback(message);\r\n      }\r\n    });\r\n\r\n    // handle local signal for a specific node on a specific chain\r\n    reporting.on('local-signal', async (signal) => {\r\n      Logger.info(`Receive local-signal: ${signal} for node ${nodeId}`);\r\n      const message: ReportingMessage = { ...payload, signal };\r\n      const update: MonitoringChainStatus = {\r\n        [message.nodeId]: { [message.signal.status]: true },\r\n      };\r\n      let workflowNode = this.workflow[message.chainId];\r\n      if (!workflowNode) {\r\n        workflowNode = {};\r\n      }\r\n      const prev = workflowNode.status;\r\n      const next = { ...prev, ...update };\r\n      workflowNode.status = next;\r\n    });\r\n    return reporting;\r\n  }\r\n\r\n  /**\r\n   * Gets the status for a specific chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {ChainStatus|undefined} The chain status if exists\r\n   */\r\n  getChainStatus(chainId: string): MonitoringChainStatus | undefined {\r\n    return this.workflow[chainId]?.status;\r\n  }\r\n\r\n  getChainSetupCount(chainId: string): number | undefined {\r\n    return this.workflow[chainId]?.setupCount;\r\n  }\r\n\r\n  setChainSetupCount(chainId: string, count: number): void {\r\n    if (!this.workflow[chainId]) {\r\n      this.workflow[chainId] = {};\r\n    }\r\n    this.workflow[chainId].setupCount = count;\r\n  }\r\n\r\n  //\r\n  async handleChildChainCompletion(childChainId: string) {\r\n    const childEntry = this.chainHierarchy.get(childChainId);\r\n    if (!childEntry || !childEntry.parentId) return;\r\n\r\n    const parentEntry = this.chainHierarchy.get(childEntry.parentId);\r\n    if (parentEntry) {\r\n      parentEntry.completedChildren.add(childChainId);\r\n      await this.checkChainReadiness(childEntry.parentId);\r\n    }\r\n  }\r\n\r\n  trackChildChain(parentChainId: string, childChainId: string) {\r\n    const parentEntry = this.chainHierarchy.get(parentChainId) || {\r\n      children: [],\r\n      completedChildren: new Set(),\r\n    };\r\n    parentEntry.children.push(childChainId);\r\n    this.chainHierarchy.set(parentChainId, parentEntry);\r\n\r\n    this.chainHierarchy.set(childChainId, {\r\n      parentId: parentChainId,\r\n      children: [],\r\n      completedChildren: new Set(),\r\n    });\r\n  }\r\n\r\n  private async checkChainReadiness(chainId: string) {\r\n    try {\r\n      const entry = this.chainHierarchy.get(chainId);\r\n      if (!entry) {\r\n        Logger.error(`No hierarchy entry found for chain ${chainId}`);\r\n        return;\r\n      }\r\n\r\n      const supervisor = NodeSupervisor.retrieveService();\r\n      const chain = supervisor.getChain(chainId);\r\n      if (!chain) {\r\n        Logger.error(`No chain found for id ${chainId}`);\r\n        return;\r\n      }\r\n\r\n      const workflowNode = this.workflow[chainId];\r\n      if (!workflowNode) {\r\n        throw new Error(`No workflow found for chain ${chainId}`);\r\n      }\r\n      const setupCount = workflowNode.setupCount || 0;\r\n      const config = chain.config.length || 0;\r\n\r\n      Logger.info(\r\n        `Chain ${chainId} setup status: ${setupCount}/${config} configs ready`,\r\n      );\r\n      Logger.info(\r\n        `Children completed: ${entry.completedChildren.size}/${entry.children.length}`,\r\n      );\r\n\r\n      if (\r\n        setupCount >= config &&\r\n        entry.children.length === entry.completedChildren.size\r\n      ) {\r\n        try {\r\n          await supervisor.handleRequest({\r\n            signal: NodeSignal.CHAIN_START_PENDING,\r\n            id: chainId,\r\n          });\r\n          Logger.info(\r\n            `Chain ${chainId} readiness check completed, start signal sent`,\r\n          );\r\n        } catch (error) {\r\n          Logger.error(\r\n            `Failed to send start signal for chain ${chainId}: ${(error as Error).message}`,\r\n          );\r\n          throw error;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error during chain readiness check for ${chainId}: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n","import {\r\n  PipelineData,\r\n  PipelineMeta,\r\n  ProcessorCallback,\r\n  ServiceConfig,\r\n} from 'types/types';\r\n\r\n/**\r\n * Represents a processor that encapsulate external services within a pipeline\r\n */\r\nexport class PipelineProcessor {\r\n  /** Static callback service used by all processor instances */\r\n  static callbackService: ProcessorCallback;\r\n\r\n  /** Optional metadata associated with this processor */\r\n  private meta?: PipelineMeta;\r\n\r\n  /** Target service identifier for this processor */\r\n  private targetId: string;\r\n\r\n  /**\r\n   * Creates a new PipelineProcessor instance\r\n   * @param {ServiceConfig} config - Configuration containing targetId and optional metadata\r\n   */\r\n  constructor(config: ServiceConfig) {\r\n    this.targetId = config.targetId;\r\n    this.meta = config.meta;\r\n  }\r\n\r\n  /**\r\n   * Sets the static callback service used by all processor instances\r\n   * @param {ProcessorCallback} callbackService - The callback function to process data\r\n   */\r\n  static setCallbackService(callbackService: ProcessorCallback): void {\r\n    PipelineProcessor.callbackService = callbackService;\r\n  }\r\n\r\n  /**\r\n   * Processes input data through the callback service\r\n   * @param {PipelineData} data - Data to be processed\r\n   * @returns {Promise<PipelineData>} Processed data\r\n   */\r\n  async digest(data: PipelineData): Promise<PipelineData> {\r\n    if (PipelineProcessor.callbackService) {\r\n      return await PipelineProcessor.callbackService({\r\n        targetId: this.targetId,\r\n        meta: this.meta,\r\n        data,\r\n      });\r\n    }\r\n    // Return empty object if no callback service is configured\r\n    return {};\r\n  }\r\n}\r\n","import { Node } from './Node';\r\nimport {\r\n  ServiceCallback,\r\n  NodeSignal,\r\n  ChainStatus,\r\n  PipelineData,\r\n  SupervisorPayload,\r\n  CallbackPayload,\r\n  BrodcastSetupMessage,\r\n  ChainConfig,\r\n  ChainRelation,\r\n  NodeConfig,\r\n  NodeType,\r\n  SetupCallback,\r\n  ServiceConfig,\r\n  DefaultCallback,\r\n  ReportingCallback,\r\n  BroadcastReportingCallback,\r\n  ReportingSignalType,\r\n  NotificationStatus,\r\n} from '../types/types';\r\nimport { Logger } from '../utils/Logger';\r\nimport { PipelineProcessor } from './PipelineProcessor';\r\nimport { randomUUID } from 'node:crypto';\r\nimport { MonitoringAgent } from '../agents/MonitoringAgent';\r\nimport { NodeSupervisorLogger } from './NodeSupervisorLogger';\r\n\r\n/**\r\n * Manages the lifecycle and distribution of nodes within a processing chain\r\n */\r\nexport class NodeSupervisor {\r\n  private uid: string;\r\n  private ctn: string;\r\n  private static instance: NodeSupervisor;\r\n  private nsLogger: NodeSupervisorLogger;\r\n\r\n  // local nodes\r\n  private nodes: Map<string, Node>;\r\n  // local chains\r\n  private chains: Map<string, ChainRelation>;\r\n  //\r\n  private childChains: Map<string, string[]>;\r\n\r\n  private broadcastSetupCallback: SetupCallback;\r\n  remoteServiceCallback: ServiceCallback;\r\n\r\n  /**\r\n   * Creates a new NodeSupervisor instance\r\n   * @private\r\n   */\r\n  private constructor() {\r\n    this.uid = '@supervisor:default';\r\n    this.ctn = '@container:default';\r\n    this.nsLogger = new NodeSupervisorLogger();\r\n    this.nodes = new Map();\r\n    this.chains = new Map();\r\n    this.childChains = new Map();\r\n    this.remoteServiceCallback = DefaultCallback.SERVICE_CALLBACK;\r\n    this.broadcastSetupCallback = DefaultCallback.SETUP_CALLBACK;\r\n  }\r\n\r\n  /**\r\n   * Retrieves or creates a NodeSupervisor instance (Singleton pattern)\r\n   * @param {boolean} refresh - Whether to force create a new instance\r\n   * @returns {NodeSupervisor} The NodeSupervisor instance\r\n   */\r\n  static retrieveService(refresh: boolean = false): NodeSupervisor {\r\n    if (!NodeSupervisor.instance || refresh) {\r\n      const instance = new NodeSupervisor();\r\n      NodeSupervisor.instance = instance;\r\n    }\r\n    return NodeSupervisor.instance;\r\n  }\r\n\r\n  log(type: string) {\r\n    switch (type) {\r\n      case 'chains':\r\n        this.nsLogger.logChains(this.chains);\r\n        break;\r\n      case 'monitoring-workflow': {\r\n        const monitoring = MonitoringAgent.retrieveService();\r\n        const workflow = monitoring.getWorkflow();\r\n        this.nsLogger.logWorkflow(workflow);\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  getChain(chainId: string): ChainRelation | undefined {\r\n    return this.chains.get(chainId);\r\n  }\r\n\r\n  /**\r\n   * Sets the remote service callback function\r\n   * @param {ServiceCallback} remoteServiceCallback - The callback to handle remote service calls\r\n   */\r\n  setRemoteServiceCallback(remoteServiceCallback: ServiceCallback): void {\r\n    this.remoteServiceCallback = remoteServiceCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast setup callback function\r\n   * @param {SetupCallback} broadcastSetupCallback - The callback to handle broadcast setup signals\r\n   */\r\n  setBroadcastSetupCallback(broadcastSetupCallback: SetupCallback): void {\r\n    this.broadcastSetupCallback = broadcastSetupCallback;\r\n  }\r\n\r\n  /**\r\n   * Sets the broadcast reporting callback function\r\n   * @param {BroadcastReportingCallback} broadcastReportingCallback - The callback to handle broadcast reporting signals\r\n   */\r\n  setBroadcastReportingCallback(\r\n    broadcastReportingCallback: BroadcastReportingCallback,\r\n  ): void {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setBroadcastReportingCallback(broadcastReportingCallback);\r\n  }\r\n\r\n  /**\r\n   * Sets the monitoring reporting callback function\r\n   * @param {ReportingCallback} reportingCallback - The callback to handle monitoring reports\r\n   */\r\n  setMonitoringCallback(reportingCallback: ReportingCallback): void {\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setReportingCallback(reportingCallback);\r\n  }\r\n\r\n  /**\r\n   * Sets the unique identifier for this supervisor instance\r\n   * @param {string} uid - The unique identifier\r\n   */\r\n  setUid(uid: string) {\r\n    this.ctn = `@container:${uid}`;\r\n    this.uid = `@supervisor:${uid}`;\r\n  }\r\n\r\n  /**\r\n   * Handles supervisor requests (node setup, creation, deletion, etc.)\r\n   * @param {SupervisorPayload} payload - The request payload\r\n   * @returns {Promise<void|string>} Promise resolving to a string if applicable\r\n   */\r\n  async handleRequest(payload: SupervisorPayload): Promise<void | string> {\r\n    switch (payload.signal) {\r\n      case NodeSignal.NODE_SETUP:\r\n        Logger.header(`handle NODE_SETUP`);\r\n        return await this.setupNode(payload.config);\r\n      case NodeSignal.NODE_CREATE:\r\n        Logger.header(`handle NODE_CREATE`);\r\n        return await this.createNode(payload.params);\r\n      case NodeSignal.NODE_DELETE:\r\n        Logger.header(`handle NODE_DELETE`);\r\n        return await this.deleteNode(payload.id);\r\n      case NodeSignal.NODE_PAUSE:\r\n        Logger.header(`handle NODE_PAUSE`);\r\n        return await this.pauseNode(payload.id);\r\n      case NodeSignal.NODE_DELAY:\r\n        Logger.header(`handle NODE_DELAY`);\r\n        return await this.delayNode(payload.id, payload.delay);\r\n      case NodeSignal.NODE_RUN:\r\n        Logger.header(`handle NODE_RUN`);\r\n        return await this.runNode(payload.id, payload.data);\r\n      case NodeSignal.NODE_SEND_DATA:\r\n        Logger.header(`handle NODE_SEND_DATA`);\r\n        return await this.sendNodeData(payload.id);\r\n      case NodeSignal.CHAIN_PREPARE:\r\n        Logger.header(`handle CHAIN_PREPARE`);\r\n        return await this.prepareChainDistribution(payload.id);\r\n      case NodeSignal.CHAIN_START:\r\n        Logger.header(`handle CHAIN_START`);\r\n        return await this.startChain(payload.id, payload.data);\r\n      case NodeSignal.CHAIN_START_PENDING:\r\n        Logger.header(`handle CHAIN_START_PENDING`);\r\n        return await this.startPendingChain(payload.id);\r\n      case NodeSignal.CHAIN_DEPLOY: {\r\n        Logger.header(`handle CHAIN_DEPLOY`);\r\n        return await this.deployChain(payload.config, payload.data);\r\n      }\r\n      default:\r\n        Logger.warn(\r\n          `${this.ctn}: Unknown signal received: ${JSON.stringify(payload, null, 2)}`,\r\n        );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deploys a new processing chain\r\n   * @param {ChainConfig} config - Configuration for the new chain\r\n   * @param {PipelineData} data - Initial data to start the chain\r\n   * @returns {Promise<string>} The new chain identifier\r\n   */\r\n  private async deployChain(\r\n    config: ChainConfig,\r\n    data: PipelineData,\r\n    parentChainId?: string,\r\n  ): Promise<string> {\r\n    try {\r\n      if (!config) {\r\n        throw new Error(`${this.ctn}: Chain configuration is required`);\r\n      }\r\n      Logger.info(`${this.ctn}: Starting a new chain deployment...`);\r\n      const chainId = this.createChain(config);\r\n      await this.prepareChainDistribution(chainId);\r\n      const chain = this.chains.get(chainId);\r\n      if (chain) {\r\n        chain.dataRef = data;\r\n      }\r\n      Logger.info(\r\n        `${this.ctn}: Deployment for chain ${chainId} has successfully started...`,\r\n      );\r\n      if (parentChainId) {\r\n        const children = this.childChains.get(parentChainId) || [];\r\n        children.push(chainId);\r\n        this.childChains.set(parentChainId, children);\r\n      }\r\n      return chainId;\r\n    } catch (error) {\r\n      Logger.error(`${this.ctn}{deployChain}: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new node with the given configuration\r\n   * @param {NodeConfig} config - The node configuration\r\n   * @returns {Promise<string>} The new node identifier\r\n   */\r\n  private async createNode(config: NodeConfig): Promise<string> {\r\n    const node = new Node();\r\n    const nodeId = node.getId();\r\n    node.setConfig(config);\r\n    this.nodes.set(nodeId, node);\r\n    Logger.info(\r\n      `${this.ctn}: Node ${nodeId} created with config: ${JSON.stringify(config, null, 2)}`,\r\n    );\r\n    return nodeId;\r\n  }\r\n\r\n  /**\r\n   * Sets up a new node with the given configuration\r\n   * @param {NodeConfig} config - The node configuration\r\n   * @param {boolean} initiator - Whether the node is the chain initiator\r\n   * @returns {Promise<string>} The new node identifier\r\n   */\r\n  private async setupNode(\r\n    config: NodeConfig,\r\n    initiator: boolean = false,\r\n  ): Promise<string> {\r\n    this.updateChain([config]);\r\n    const nodeId = await this.createNode(config);\r\n    const node = this.nodes.get(nodeId);\r\n\r\n    if (!node) {\r\n      Logger.warn(`${this.ctn}: Attempted to setup undefined node`);\r\n      return nodeId;\r\n    }\r\n\r\n    await this.setRemoteMonitoringHost(config);\r\n\r\n    const processors = config.services.map(\r\n      (service) =>\r\n        new PipelineProcessor(\r\n          typeof service === 'string' ? { targetId: service } : service,\r\n        ),\r\n    );\r\n    await this.addProcessors(nodeId, processors);\r\n    Logger.info(\r\n      `${this.ctn}: Node ${nodeId} setup completed with ${processors.length} processors`,\r\n    );\r\n\r\n    if (config.nextTargetId !== undefined) {\r\n      node.setNextNodeInfo(\r\n        config.nextTargetId,\r\n        NodeType.REMOTE,\r\n        config.nextMeta,\r\n      );\r\n    } else if (!initiator) {\r\n      Logger.warn(\r\n        `${this.ctn}: Cannot set next node info: nextTargetId is undefined`,\r\n      );\r\n    }\r\n    //\r\n    this.notify(nodeId, ChainStatus.NODE_SETUP_COMPLETED, 'global-signal');\r\n    return nodeId;\r\n  }\r\n\r\n  /**\r\n   * Handles externals notifications about a chain status change\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {NotificationStatus} status - The new chain status\r\n   */\r\n  handleNotification(chainId: string, status: NotificationStatus): void {\r\n    try {\r\n      const chain = this.chains.get(chainId);\r\n      if (!chain) {\r\n        Logger.warn(`${this.ctn}: Chain with ID ${chainId} not found.`);\r\n        return;\r\n      }\r\n      const rootNodeId = chain.rootNodeId;\r\n      if (!rootNodeId) {\r\n        Logger.warn(`${this.ctn}: Root node ID missing for chain ${chainId}.`);\r\n        return;\r\n      }\r\n      const node = this.nodes.get(rootNodeId);\r\n      if (!node) {\r\n        Logger.warn(`${this.ctn}: Node with ID ${rootNodeId} not found.`);\r\n        return;\r\n      }\r\n      node.notify(status, 'global-signal');\r\n      Logger.info(\r\n        `${this.ctn}: Notification sent to node ${rootNodeId} with status ${status}.`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}: Failed to handle notification for chain ${chainId}: ${(error as Error).message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notifies a node about a chain status change\r\n   * @param {string} nodeId - The node identifier to notify\r\n   * @param {ChainStatus.Type} status - The new chain status to notify\r\n   */\r\n  private notify(\r\n    nodeId: string,\r\n    status: ChainStatus.Type,\r\n    type: ReportingSignalType = 'local-signal',\r\n  ): void {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.notify(status, type);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Can't notify non-existing node ${nodeId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds processors to a node\r\n   * @param {string} nodeId - The node identifier\r\n   * @param {PipelineProcessor[]} processors - Array of processors to add\r\n   */\r\n  async addProcessors(\r\n    nodeId: string,\r\n    processors: PipelineProcessor[],\r\n  ): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.addPipeline(processors);\r\n      Logger.info(`${this.ctn}: Processors added to Node ${nodeId}.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a node\r\n   * @param {string} nodeId - The node identifier to delete\r\n   */\r\n  private async deleteNode(nodeId: string): Promise<void> {\r\n    if (this.nodes.has(nodeId)) {\r\n      this.nodes.delete(nodeId);\r\n      Logger.info(`${this.ctn}: Node ${nodeId} deleted.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pauses a node\r\n   * @param {string} nodeId - The node identifier to pause\r\n   */\r\n  private async pauseNode(nodeId: string): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.updateStatus(ChainStatus.NODE_PAUSED);\r\n      Logger.info(`${this.ctn}: Node ${nodeId} paused.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delays the execution of a node\r\n   * @param {string} nodeId - The node identifier\r\n   * @param {number} delay - The delay in milliseconds\r\n   */\r\n  private async delayNode(nodeId: string, delay: number): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      node.setDelay(delay);\r\n      Logger.info(`${this.ctn}: Node ${nodeId} delayed by ${delay} ms.`);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new chain with the given configuration\r\n   * @param {ChainConfig} config - The chain configuration\r\n   * @returns {string} The new chain identifier\r\n   */\r\n  createChain(config: ChainConfig): string {\r\n    try {\r\n      if (!config || !Array.isArray(config)) {\r\n        throw new Error('Invalid chain configuration: config must be an array');\r\n      }\r\n      const timestamp = Date.now();\r\n      const chainId = `${this.uid}-${timestamp}-${randomUUID().slice(0, 8)}`;\r\n      const relation: ChainRelation = {\r\n        config,\r\n      };\r\n\r\n      this.chains.set(chainId, relation);\r\n      const monitoringHost = config[0]?.monitoringHost;\r\n      const count = Array.isArray(config) ? config.length : 0;\r\n\r\n      if (count > 0) {\r\n        config.forEach((value: NodeConfig, index: number) => {\r\n          if (value) {\r\n            value.index = index;\r\n            value.count = count;\r\n            value.monitoringHost = monitoringHost;\r\n          }\r\n        });\r\n      } else {\r\n        Logger.warn(`${this.ctn}: Chain configuration is empty`);\r\n      }\r\n\r\n      Logger.header(`${this.ctn}: Chain ${chainId} creation has started...`);\r\n      return chainId;\r\n    } catch (error) {\r\n      Logger.header(`${this.ctn}{createChain}: ${(error as Error).message}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates an existing chain with new configurations\r\n   * @param {ChainConfig} config - The new chain configurations to add\r\n   * @returns {string} The chain identifier\r\n   */\r\n  private updateChain(config: ChainConfig): string {\r\n    if (config.length === 0 || !config[0].chainId) {\r\n      throw new Error('Invalid chain configuration');\r\n    }\r\n    const chainId = config[0].chainId;\r\n    let relation = this.chains.get(chainId);\r\n\r\n    if (relation) {\r\n      relation.config = relation.config.concat(config);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} updated with ${config.length} new configurations`,\r\n      );\r\n    } else {\r\n      relation = {\r\n        config: config,\r\n      };\r\n      this.chains.set(chainId, relation);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} created with ${config.length} configurations`,\r\n      );\r\n    }\r\n    return chainId;\r\n  }\r\n\r\n  /**\r\n   * Sets the remote monitoring host for a chain\r\n   * @param {NodeConfig} config - The node configuration containing the monitoring host\r\n   */\r\n  private async setRemoteMonitoringHost(config: NodeConfig): Promise<void> {\r\n    const remoteMonitoringHost = config.monitoringHost;\r\n    if (!remoteMonitoringHost) {\r\n      throw new Error(\r\n        `${this.ctn}: No Monitoring Host set for Chain ${config.chainId} during distribution`,\r\n      );\r\n    }\r\n    const monitoring = MonitoringAgent.retrieveService();\r\n    monitoring.setRemoteMonitoringHost(config.chainId, remoteMonitoringHost);\r\n  }\r\n\r\n  /**\r\n   * Prepares the distribution of a processing chain\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  async prepareChainDistribution(chainId: string): Promise<void> {\r\n    try {\r\n      Logger.header(\r\n        `${this.ctn}: Chain distribution for ${chainId} in progress...`,\r\n      );\r\n      const chain = this.chains.get(chainId);\r\n      if (!chain) {\r\n        throw new Error(`${this.ctn}: Chain ${chainId} not found`);\r\n      }\r\n      const chainConfig: ChainConfig = chain.config;\r\n      const localConfigs: NodeConfig[] = chainConfig.filter(\r\n        (config) => config.location === 'local',\r\n      );\r\n      const remoteConfigs: NodeConfig[] = chainConfig.filter(\r\n        (config) => config.location === 'remote',\r\n      );\r\n\r\n      if (!localConfigs) {\r\n        throw new Error('Local config undefined');\r\n      }\r\n\r\n      if (localConfigs.length > 0) {\r\n        const rootNodeId = await this.setupNode(\r\n          { ...localConfigs[0], chainId },\r\n          true,\r\n        );\r\n        chain.rootNodeId = rootNodeId;\r\n\r\n        let prevNodeId = rootNodeId;\r\n        for (let i = 1; i < localConfigs.length; i++) {\r\n          const currentNodeId = await this.setupNode(\r\n            {\r\n              ...localConfigs[i],\r\n              chainId,\r\n            },\r\n            true,\r\n          );\r\n          const prevNode = this.nodes.get(prevNodeId);\r\n          if (prevNode) {\r\n            prevNode.setNextNodeInfo(currentNodeId, NodeType.LOCAL);\r\n          }\r\n          prevNodeId = currentNodeId;\r\n        }\r\n\r\n        if (!remoteConfigs) {\r\n          throw new Error('Remote config undefined');\r\n        }\r\n\r\n        // Set the last local node to point to the first remote service\r\n        if (remoteConfigs.length > 0 && remoteConfigs[0].services.length > 0) {\r\n          const lastLocalNode = this.nodes.get(prevNodeId);\r\n          if (lastLocalNode) {\r\n            const nextService = remoteConfigs[0].services[0];\r\n            lastLocalNode.setNextNodeInfo(\r\n              typeof nextService === 'string'\r\n                ? nextService\r\n                : nextService.targetId,\r\n              NodeType.REMOTE,\r\n              typeof nextService === 'string' ? void 0 : nextService.meta,\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        Logger.warn(\r\n          `${this.ctn}: No local config found for chain ${chainId}. Root node unavailable.`,\r\n        );\r\n      }\r\n      try {\r\n        if (remoteConfigs.length > 0) {\r\n          const updatedRemoteConfigs: NodeConfig[] = remoteConfigs.map(\r\n            (config, index) => {\r\n              const nextConfig: string | ServiceConfig =\r\n                remoteConfigs[index + 1]?.services[0];\r\n              const nodeConfig: NodeConfig = {\r\n                ...config,\r\n                nextTargetId: nextConfig\r\n                  ? typeof nextConfig === 'string'\r\n                    ? nextConfig\r\n                    : nextConfig.targetId\r\n                  : undefined,\r\n                nextMeta:\r\n                  nextConfig && typeof nextConfig !== 'string'\r\n                    ? nextConfig.meta\r\n                    : undefined,\r\n              };\r\n              return nodeConfig;\r\n            },\r\n          );\r\n\r\n          await this.broadcastNodeSetupSignal(chainId, updatedRemoteConfigs);\r\n        }\r\n      } catch (error) {\r\n        Logger.error(\r\n          `${this.ctn}{prepareChainDistribution, broadcast}: ${(error as Error).message}`,\r\n        );\r\n      }\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}{prepareChainDistribution}: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a setup signal for remote nodes in a chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {ChainConfig} remoteConfigs - The remote node configurations\r\n   */\r\n  async broadcastNodeSetupSignal(\r\n    chainId: string,\r\n    remoteConfigs: ChainConfig,\r\n  ): Promise<void> {\r\n    const message: BrodcastSetupMessage = {\r\n      signal: NodeSignal.NODE_SETUP,\r\n      chain: {\r\n        id: chainId,\r\n        config: remoteConfigs,\r\n      },\r\n    };\r\n\r\n    try {\r\n      await this.broadcastSetupCallback(message);\r\n      Logger.info(\r\n        `${this.ctn}: Node creation signal broadcasted with chainId: ${chainId} for remote configs`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(\r\n        `${this.ctn}: Failed to broadcast node creation signal: ${error}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts a pending chain\r\n   * @param {string} chainId - The chain identifier\r\n   */\r\n  async startPendingChain(chainId: string) {\r\n    const chain = this.chains.get(chainId);\r\n    const data = chain?.dataRef;\r\n    if (data) {\r\n      await this.startChain(chainId, data);\r\n    } else {\r\n      Logger.error(`${this.ctn}: Can't start chain ${chainId}`);\r\n      throw new Error('Something went wrong while starting pending chain');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts a new chain\r\n   * @param {string} chainId - The chain identifier\r\n   * @param {PipelineData} data - The initial data to process\r\n   */\r\n  async startChain(chainId: string, data: PipelineData): Promise<void> {\r\n    Logger.header(`Chain ${chainId} requested...`);\r\n    const chain = this.chains.get(chainId);\r\n    if (!chain) {\r\n      Logger.warn(`Chain ${chainId} not found.`);\r\n      return;\r\n    }\r\n    const rootNodeId = chain.rootNodeId;\r\n    if (!rootNodeId) {\r\n      Logger.error(`${this.ctn}: Root node ID for chain ${chainId} not found.`);\r\n      return;\r\n    }\r\n\r\n    const rootNode = this.nodes.get(rootNodeId);\r\n\r\n    if (!rootNode) {\r\n      Logger.error(\r\n        `${this.ctn}: Root node ${rootNodeId} for chain ${chainId} not found.`,\r\n      );\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this.runNode(rootNodeId, data);\r\n      Logger.info(\r\n        `${this.ctn}: Chain ${chainId} started with root node ${rootNodeId}.`,\r\n      );\r\n    } catch (error) {\r\n      Logger.error(`${this.ctn}: Failed to start chain ${chainId}: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a node with the given data\r\n   * @param {string} nodeId - The node identifier\r\n   * @param {PipelineData} data - The data to process\r\n   */\r\n  private async runNode(nodeId: string, data: PipelineData): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      await node.execute(data);\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a node based on the given callback payload\r\n   * @param {CallbackPayload} payload - The payload containing target ID, chain ID, and data\r\n   */\r\n  async runNodeByRelation(payload: CallbackPayload): Promise<void> {\r\n    try {\r\n      const { targetId, chainId, data } = payload;\r\n      Logger.info(`Received data for node hosting target ${targetId}`);\r\n      if (chainId === undefined) {\r\n        throw new Error('chainId is undefined');\r\n      }\r\n      if (targetId === undefined) {\r\n        throw new Error('targetId is undefined');\r\n      }\r\n      const node = this.getNodesByServiceAndChain(targetId, chainId);\r\n      if (!node || node.length === 0) {\r\n        throw new Error(\r\n          `No node found for targetId ${targetId} and chainId ${chainId}`,\r\n        );\r\n      }\r\n      const nodeId = node[0].getId();\r\n      if (nodeId === undefined) {\r\n        throw new Error(\r\n          `No node ID exists for targetId ${targetId} and chainId ${chainId}`,\r\n        );\r\n      }\r\n      await this.handleRequest({\r\n        signal: NodeSignal.NODE_RUN,\r\n        id: nodeId,\r\n        data: data as PipelineData,\r\n      });\r\n    } catch (error) {\r\n      Logger.error(`Error in runNodeByRelation: ${(error as Error).message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends data from a node\r\n   * @param {string} nodeId - The node identifier\r\n   */\r\n  private async sendNodeData(nodeId: string): Promise<void> {\r\n    const node = this.nodes.get(nodeId);\r\n    if (node) {\r\n      try {\r\n        await node.sendData();\r\n      } catch (err) {\r\n        const error = err as Error;\r\n        Logger.error(\r\n          `${this.ctn}: Node ${nodeId} send data failed: ${error.message}`,\r\n        );\r\n      }\r\n    } else {\r\n      Logger.warn(`${this.ctn}: Node ${nodeId} not found.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets all the nodes managed by this supervisor\r\n   * @returns {Map<string, Node>} Map of nodes\r\n   */\r\n  getNodes(): Map<string, Node> {\r\n    return this.nodes;\r\n  }\r\n\r\n  /**\r\n   * Gets all nodes associated with a specific service and chain\r\n   * @param {string} serviceUid - The service identifier\r\n   * @param {string} chainId - The chain identifier\r\n   * @returns {Node[]} Array of nodes matching the criteria\r\n   */\r\n  getNodesByServiceAndChain(serviceUid: string, chainId: string): Node[] {\r\n    return Array.from(this.nodes.values()).filter((node) => {\r\n      const nodeConfig = node.getConfig();\r\n      if (!nodeConfig) {\r\n        return false;\r\n      }\r\n      return (\r\n        nodeConfig.chainId === chainId &&\r\n        nodeConfig.services.some((service) =>\r\n          typeof service === 'string'\r\n            ? service === serviceUid\r\n            : service.targetId === serviceUid,\r\n        )\r\n      );\r\n    });\r\n  }\r\n}\r\n","import { Logger } from 'utils/Logger';\r\nimport { ChainRelation } from '../types/types';\r\nimport { Workflow } from '../agents/MonitoringAgent';\r\n\r\nexport class NodeSupervisorLogger {\r\n  constructor() {}\r\n  logChains(chains: Map<string, ChainRelation>) {\r\n    Logger.debug('Logging chains content:');\r\n    chains.forEach((relation, chainId) => {\r\n      Logger.debug(`Chain ID: ${chainId}`);\r\n      Logger.debug(`Root Node ID: ${relation.rootNodeId || 'None'}`);\r\n      Logger.debug(\r\n        `Data Reference: ${JSON.stringify(relation.dataRef, null, 2) || 'None'}`,\r\n      );\r\n      Logger.debug('Chain Configuration:');\r\n      relation.config.forEach((nodeConfig, index) => {\r\n        Logger.debug(`  Node ${index + 1}:`);\r\n        Logger.debug(`    Services: ${JSON.stringify(nodeConfig.services)}`);\r\n        Logger.debug(`    Chain ID: ${nodeConfig.chainId}`);\r\n        Logger.debug(`    Index: ${nodeConfig.index}`);\r\n        Logger.debug(`    Count: ${nodeConfig.count}`);\r\n        Logger.debug(`    Location: ${nodeConfig.location}`);\r\n        Logger.debug(`    Next Target ID: ${nodeConfig.nextTargetId}`);\r\n        Logger.debug(`    Chain Type: ${nodeConfig.chainType}`);\r\n        Logger.debug(`    Monitoring Host: ${nodeConfig.monitoringHost}`);\r\n        Logger.debug(`    Child Mode: ${nodeConfig.childMode}`);\r\n      });\r\n    });\r\n  }\r\n\r\n  logWorkflow(workflow: Workflow) {\r\n    Object.entries(workflow).forEach(([workflowId, node]) => {\r\n      Logger.header(`Workflow Node: ${workflowId}`);\r\n      Object.entries(node).forEach(([key, value]) => {\r\n        Logger.debug(`- ${key}: ${JSON.stringify(value)}`);\r\n      });\r\n    });\r\n  }\r\n}\r\n","import {\r\n  ChainStatus,\r\n  NodeSignal,\r\n  ReportingMessage,\r\n  SupervisorPayloadStartPendingChain,\r\n} from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { MonitoringAgent } from '../agents/MonitoringAgent';\r\nimport { Logger } from '../utils/Logger';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Default class, responsible for handling monitoring signals.\r\n   * Processes reporting messages and triggers actions based on the message signal.\r\n   */\r\n  export class MonitoringSignalHandler {\r\n    /**\r\n     * Handles a reporting message and triggers appropriate actions based on the signal type.\r\n     * This function serves as a flexible entry point for processing intercepted signals\r\n     * originating from the reporting agent, allowing adaptation to various system needs.\r\n     * Specifically, it processes node setup completion signals in a chain, but can be\r\n     * extended to handle other signal types.\r\n     *\r\n     * Note: This is a bridge between global messages and the rest of the system,\r\n     * enabling the dispatch of actions tailored to specific goals.\r\n     *\r\n     * @static\r\n     * @async\r\n     * @param {ReportingMessage} message - The message containing the signal and associated chain data.\r\n     * @returns {Promise<void>} - Resolves when the message is fully processed.\r\n     */\r\n    static async handle(message: ReportingMessage) {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      const status = message.signal?.status;\r\n      switch (status) {\r\n        /*\r\n         *\r\n         */\r\n        case ChainStatus.NODE_SETUP_COMPLETED: {\r\n          let count = monitoring.getChainSetupCount(message.chainId);\r\n          if (!count) {\r\n            monitoring.setChainSetupCount(message.chainId, 1);\r\n          } else {\r\n            monitoring.setChainSetupCount(message.chainId, count + 1);\r\n          }\r\n          count = monitoring.getChainSetupCount(message.chainId);\r\n          if (count && count >= message.count) {\r\n            const supervisor = NodeSupervisor.retrieveService();\r\n            const payload: SupervisorPayloadStartPendingChain = {\r\n              signal: NodeSignal.CHAIN_START_PENDING,\r\n              id: message.chainId,\r\n            };\r\n            await supervisor.handleRequest(payload);\r\n            Logger.info({\r\n              message: `MonitoringSignalHandler: Chain setup completed`,\r\n            });\r\n          }\r\n          break;\r\n        }\r\n        /*\r\n         *\r\n         */\r\n        case ChainStatus.CHILD_CHAIN_COMPLETED:\r\n          await monitoring.handleChildChainCompletion(\r\n            '' /*message.childChainId!*/,\r\n          );\r\n          break;\r\n        /*\r\n         *\r\n         */\r\n        default:\r\n          Logger.info({\r\n            message: `MonitoringSignalHandler: Signal handler not found for ${message.signal}`,\r\n          });\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Buffer } from 'buffer';\r\nimport * as http from 'http';\r\nimport * as https from 'https';\r\n\r\n/**\r\n * Sends a POST request to a specified URL with provided JSON data.\r\n *\r\n * This function handles both HTTP and HTTPS protocols, selecting the appropriate\r\n * module (`http` or `https`) based on the URL's protocol. It sends a JSON payload\r\n * and returns the server's response as a string.\r\n *\r\n * @param {URL} url - The destination URL for the POST request.\r\n * @param {string} data - JSON data to be sent in the POST request body.\r\n * @returns {Promise<string>} - A promise that resolves with the response body as a string.\r\n *\r\n * @throws {Error} Throws an error if the response status code is not in the 2xx range,\r\n * or if there is a network or request-related issue.\r\n */\r\nexport const post = async (url: URL, data: string): Promise<string> => {\r\n  const useSSL = url.protocol === 'https:';\r\n  const options = {\r\n    hostname: url.hostname,\r\n    port: url.port || (useSSL ? '443' : '80'),\r\n    path: url.pathname,\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n      'Content-Length': Buffer.byteLength(data),\r\n    },\r\n  };\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const req = (useSSL ? https : http).request(options, (res) => {\r\n      let data = '';\r\n      res.on('data', (chunk) => {\r\n        data += chunk;\r\n      });\r\n\r\n      res.on('end', () => {\r\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\r\n          resolve(data);\r\n        } else {\r\n          reject(\r\n            new Error(\r\n              `HTTP Error: ${res.statusCode} ${res.statusMessage} - URL: ${options.hostname}${options.path}`,\r\n            ),\r\n          );\r\n        }\r\n      });\r\n    });\r\n\r\n    req.on('error', (error) => {\r\n      reject(new Error(`Request failed to ${url.href}: ${error.message}`));\r\n    });\r\n\r\n    req.write(data);\r\n    req.end();\r\n  });\r\n};\r\n","import { ReportingMessage, BroadcastReportingMessage } from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { Logger } from '../utils/Logger';\r\nimport { post } from '../utils/http';\r\nimport { MonitoringAgent } from 'agents/MonitoringAgent';\r\nimport { Ext as ExtDMSH } from 'extensions/DefaultMonitoringSignalHandler';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Type defining a callback to handle reporting signals\r\n   * @param {ReportingMessage} message - The reporting message containing signal and metadata\r\n   * @returns {Promise<void>}\r\n   */\r\n  export type ReportSignalHandlerCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    message: ReportingMessage,\r\n  ) => Promise<void>;\r\n\r\n  /**\r\n   * Type defining a callback to resolve the monitoring host for a chain\r\n   * @param {string} chainId - The ID of the chain to find the monitoring host for\r\n   * @returns {Promise<string | undefined>}\r\n   */\r\n  export type MonitoringResolverCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    chainId: string,\r\n  ) => Promise<string | undefined>;\r\n\r\n  /**\r\n   * Interface for the monitoring payload\r\n   */\r\n  export interface MCPayload {\r\n    message: ReportingMessage;\r\n    reportSignalHandler: ReportSignalHandlerCallback;\r\n  }\r\n\r\n  /**\r\n   * Interface for the broadcast reporting payload\r\n   */\r\n  export interface BRCPayload {\r\n    message: BroadcastReportingMessage;\r\n    path: string;\r\n    monitoringResolver: MonitoringResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Default callback for reporting, to be set on the initial supervisor\r\n   * @param {MCPayload} payload - Contains the message and report signal handler callback\r\n   * @returns {Promise<void>}\r\n   */\r\n  export const reportingCallback = async (\r\n    payload: MCPayload,\r\n  ): Promise<void> => {\r\n    const { message, reportSignalHandler } = payload;\r\n    await reportSignalHandler(message);\r\n  };\r\n\r\n  /**\r\n   * Interface to configure default reporting callbacks\r\n   */\r\n  export interface DefaultReportingCallbackPayload {\r\n    paths: { notify: string };\r\n    reportSignalHandler?: ReportSignalHandlerCallback;\r\n    monitoringResolver?: MonitoringResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Default handler for reporting signals\r\n   * Primarily handles the start of chains once setup is completed\r\n   * @param {ReportingMessage} message - The reporting message containing the signal and metadata\r\n   * @returns {Promise<void>}\r\n   */\r\n  const defaultReportSignalHandler = async (\r\n    message: ReportingMessage,\r\n  ): Promise<void> => {\r\n    Logger.info({ message: `${JSON.stringify(message, null, 2)}` });\r\n    await ExtDMSH.MonitoringSignalHandler.handle(message);\r\n  };\r\n\r\n  /**\r\n   * Default resolver to find the monitoring host for a chain\r\n   * @param {string} chainId - The ID of the chain to locate the monitoring host\r\n   * @returns {Promise<string | undefined>}\r\n   */\r\n  const defaultMonitoringResolver = async (\r\n    chainId: string,\r\n  ): Promise<string | undefined> => {\r\n    try {\r\n      const monitoring = MonitoringAgent.retrieveService();\r\n      const monitoringHost = monitoring.getRemoteMonitoringHost(chainId);\r\n      if (monitoringHost !== undefined) {\r\n        Logger.info({\r\n          message: `DRC: Resolving host for monitoring: ${monitoringHost}`,\r\n        });\r\n        return monitoringHost;\r\n      } else throw new Error('Monitoring host not found');\r\n    } catch (error) {\r\n      Logger.error({ message: (error as Error).message });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handles broadcasting reporting messages to monitoring hosts\r\n   * @param {BRCPayload} payload - Contains the broadcast message, path, and monitoring resolver\r\n   * @returns {Promise<void>}\r\n   */\r\n  const broadcastReportingCallback = async (\r\n    payload: BRCPayload,\r\n  ): Promise<void> => {\r\n    const { message, path, monitoringResolver } = payload;\r\n    const monitoringHost = await monitoringResolver(message.chainId);\r\n    const url = new URL(path, monitoringHost);\r\n    const data = JSON.stringify(message);\r\n    Logger.info(`BroadcastReportingCallback: Sending message to ${url}`);\r\n    await post(url, data);\r\n  };\r\n\r\n  /**\r\n   * Configures monitoring callbacks for the supervisor\r\n   * - Sets up the local reporting callback\r\n   * - Sets up the broadcast reporting callback\r\n   * @param {DefaultReportingCallbackPayload} dcPayload - Configuration for paths and handlers\r\n   * @returns {Promise<void>}\r\n   */\r\n  export const setMonitoringCallbacks = async (\r\n    dcPayload: DefaultReportingCallbackPayload,\r\n  ): Promise<void> => {\r\n    const { paths, reportSignalHandler, monitoringResolver } = dcPayload;\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n\r\n    supervisor.setMonitoringCallback(\r\n      async (message: ReportingMessage): Promise<void> => {\r\n        const payload: MCPayload = {\r\n          message,\r\n          reportSignalHandler:\r\n            reportSignalHandler ?? defaultReportSignalHandler,\r\n        };\r\n        await reportingCallback(payload);\r\n      },\r\n    );\r\n\r\n    if (reportSignalHandler) {\r\n      Logger.info('Monitoring Callback set with custom Signal Handler');\r\n    } else {\r\n      Logger.info('Monitoring Callback set with default Signal Handler');\r\n    }\r\n\r\n    supervisor.setBroadcastReportingCallback(\r\n      async (message: BroadcastReportingMessage): Promise<void> => {\r\n        const payload: BRCPayload = {\r\n          message,\r\n          path: paths.notify,\r\n          monitoringResolver: monitoringResolver ?? defaultMonitoringResolver,\r\n        };\r\n        await broadcastReportingCallback(payload);\r\n      },\r\n    );\r\n\r\n    if (monitoringResolver) {\r\n      Logger.info('Broadcast Reporting Callback set with custom Resolver');\r\n    } else {\r\n      Logger.info('Broadcast Reporting Callback set with default Resolver');\r\n    }\r\n  };\r\n}\r\n","import { Logger } from '../utils/Logger';\r\nimport {\r\n  BrodcastSetupMessage,\r\n  CallbackPayload,\r\n  ChainConfig,\r\n  PipelineMeta,\r\n} from '../types/types';\r\nimport { NodeSupervisor } from '../core/NodeSupervisor';\r\nimport { post } from '../utils/http';\r\n\r\nexport namespace Ext {\r\n  /**\r\n   * Type defining a host resolution function to build a URL from target information\r\n   */\r\n  export type HostResolverCallback = (\r\n    // eslint-disable-next-line no-unused-vars\r\n    targetId: string,\r\n    // eslint-disable-next-line no-unused-vars\r\n    meta?: PipelineMeta,\r\n  ) => string | undefined;\r\n\r\n  /**\r\n   * Interface for the setup configuration broadcast payload\r\n   */\r\n  export interface BSCPayload {\r\n    message: BrodcastSetupMessage;\r\n    hostResolver: HostResolverCallback;\r\n    path: string;\r\n  }\r\n\r\n  /**\r\n   * Manages broadcasting setup configurations to different remote nodes\r\n   * @param {BSCPayload} payload - Contains the message to broadcast, host resolution function, and path\r\n   */\r\n  export const broadcastSetupCallback = async (\r\n    payload: BSCPayload,\r\n  ): Promise<void> => {\r\n    const { message, hostResolver, path } = payload;\r\n    Logger.info(`Broadcast message: ${JSON.stringify(message, null, 2)}`);\r\n    const chainConfigs: ChainConfig = message.chain.config;\r\n    const chainId: string = message.chain.id;\r\n\r\n    for (const config of chainConfigs) {\r\n      if (config.services.length === 0) {\r\n        Logger.warn('Empty services array encountered in config');\r\n        continue;\r\n      }\r\n      const service = config.services[0];\r\n      const targetId: string =\r\n        typeof service === 'string' ? service : service.targetId;\r\n      const meta = typeof service === 'string' ? undefined : service.meta;\r\n\r\n      const host = hostResolver(targetId, meta);\r\n      if (!host) {\r\n        Logger.warn(`No container address found for targetId: ${targetId}`);\r\n        continue;\r\n      }\r\n      try {\r\n        // Send a POST request to set up the node on a remote container with the specified host address\r\n        const data = JSON.stringify({\r\n          chainId,\r\n          remoteConfigs: config,\r\n        });\r\n        const url = new URL(path, host);\r\n        void post(url, data);\r\n      } catch (error) {\r\n        Logger.error(\r\n          `Unexpected error sending setup request to ${host} for targetId ${targetId}: ${(error as Error).message}`,\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Interface for the payload of remote service calls\r\n   */\r\n  export interface RSCPayload {\r\n    cbPayload: CallbackPayload;\r\n    hostResolver: HostResolverCallback;\r\n    path: string;\r\n  }\r\n\r\n  /**\r\n   * Manages sending data to remote services\r\n   * @param {RSCPayload} payload - Contains data to send, host resolution function, and path\r\n   */\r\n  export const remoteServiceCallback = async (payload: RSCPayload) => {\r\n    const { cbPayload, hostResolver, path } = payload;\r\n    Logger.info(\r\n      `Service callback payload: ${JSON.stringify(payload, null, 2)}`,\r\n    );\r\n    try {\r\n      if (!cbPayload.chainId) {\r\n        throw new Error('payload.chainId is undefined');\r\n      }\r\n\r\n      const nextConnectorUrl = hostResolver(cbPayload.targetId, cbPayload.meta);\r\n      if (!nextConnectorUrl) {\r\n        throw new Error(\r\n          `Next connector URI not found for the following target service: ${cbPayload.targetId}`,\r\n        );\r\n      }\r\n\r\n      const url = new URL(path, nextConnectorUrl);\r\n      Logger.info(`Sending data to next connector on: ${url.href}`);\r\n      const data = JSON.stringify(cbPayload);\r\n      await post(url, data);\r\n    } catch (error) {\r\n      Logger.error(\r\n        `Error sending data to next connector: ${(error as Error).message}`,\r\n      );\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Interface for configuring default callbacks\r\n   */\r\n  export interface DefaultCallbackPayload {\r\n    paths: { setup: string; run: string };\r\n    hostResolver: HostResolverCallback;\r\n  }\r\n\r\n  /**\r\n   * Configures resolution callbacks for the node supervisor\r\n   * - Configures the setup broadcast callback\r\n   * - Configures the remote service callback\r\n   * @param {DefaultCallbackPayload} dcPayload - Configuration for paths and host resolver\r\n   */\r\n  export const setResolverCallbacks = async (\r\n    dcPayload: DefaultCallbackPayload,\r\n  ): Promise<void> => {\r\n    const { paths, hostResolver } = dcPayload;\r\n    const supervisor = NodeSupervisor.retrieveService();\r\n\r\n    supervisor.setBroadcastSetupCallback(\r\n      async (message: BrodcastSetupMessage): Promise<void> => {\r\n        const payload: BSCPayload = {\r\n          message,\r\n          hostResolver,\r\n          path: paths.setup,\r\n        };\r\n        await broadcastSetupCallback(payload);\r\n      },\r\n    );\r\n\r\n    supervisor.setRemoteServiceCallback(\r\n      async (cbPayload: CallbackPayload): Promise<void> => {\r\n        const payload: RSCPayload = {\r\n          cbPayload,\r\n          hostResolver,\r\n          path: paths.run,\r\n        };\r\n        await remoteServiceCallback(payload);\r\n      },\r\n    );\r\n  };\r\n}\r\n","import { CombineStrategy, CombineFonction, PipelineData } from '../types/types';\r\n\r\nexport class PipelineDataCombiner {\r\n  private strategy: CombineStrategy.Type;\r\n  private customCombineFunction?: CombineFonction;\r\n\r\n  constructor(\r\n    strategy: CombineStrategy.Type = CombineStrategy.MERGE,\r\n    customCombineFunction?: CombineFonction,\r\n  ) {\r\n    this.strategy = strategy;\r\n    this.customCombineFunction = customCombineFunction;\r\n  }\r\n\r\n  private merge(dataSets: PipelineData[]): PipelineData {\r\n    return dataSets.flat();\r\n  }\r\n\r\n  private union(dataSets: PipelineData[]): PipelineData {\r\n    const mergedData = this.merge(dataSets);\r\n    if (Array.isArray(mergedData)) {\r\n      return Array.from(new Set(mergedData));\r\n    }\r\n    throw new Error('PipelineData must be an array.');\r\n  }\r\n\r\n  applyStrategy(dataSets: PipelineData[]): PipelineData {\r\n    switch (this.strategy) {\r\n      case CombineStrategy.MERGE:\r\n        return this.merge(dataSets);\r\n      case CombineStrategy.UNION:\r\n        return this.union(dataSets);\r\n      case CombineStrategy.CUSTOM:\r\n        if (this.customCombineFunction) {\r\n          return this.customCombineFunction(dataSets);\r\n        }\r\n        throw new Error('Custom combine function is not defined.');\r\n      default:\r\n        throw new Error(`Unknown combine strategy: ${this.strategy}`);\r\n    }\r\n  }\r\n\r\n  setStrategy(strategy: CombineStrategy.Type): void {\r\n    this.strategy = strategy;\r\n  }\r\n\r\n  setCustomCombineFunction(combineFunction: CombineFonction): void {\r\n    this.customCombineFunction = combineFunction;\r\n  }\r\n}\r\n"],"mappings":"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","names":["Ext","DefaultCallback","NodeType","DataType","CombineStrategy","ChainType","ChainStatus","NodeSignal","import_node_crypto","EventEmitter","import_node_crypto","Ext","data","Ext","Ext","Ext"]}